# 未解决问题阈值:20题
# 没有解决干净的problem:
1. 25min内解不出来(还剩-45 chances): 374, 371, 621, 134, 127, 739, 647, 416, 190,337,31, 103, 105, 109, 113, 120, 95, 205, 437, 645, 725, 8, 47, 130, 131 ,133, 139, 143, 148, 152, 179, 187, 168, 200, 206, 213, 216, 220, 229, 240, 146, 241, 304, 264, 274, 284, 279, 287, 300, 252, 253, 96, 93, 80, 437
2. 题目看不懂: 所有leetcode挂todo的题目: 806, 893, 921, 202
3. 有更巧妙解法: 905, 832, 557, 728, 867, 872, 412, 566, 485, 258, 690, 389, 788, 349, 217, 796, 14, 110, 219,605, 67, 27, 268, 409, 643, 830, 235, 101, 83, 92, 153, 260
4. 解法需要特殊数学知识: 812(3点坐标求三角形面积), 371(二进制), 476(二进制), 192
5. 需复习(第一项看解法后才解出来的):365, 331, 334, 373, 55, 50, 290, 22, 138, 39, 443, 108, 69, 234, 922, 507, 897, 257, 859, 653, 122, 108, 784, 387, 172, 453, 492, 88 ,204, 350, 434, 501, 475, 949, 15, 697, 189, 414, 633, 680, 24, 937,482, 36, 98, 532, 147,74

## 思考
- 哪种情况适合使用左右指针碰撞算法了: 917,922,859,快排,345, 15, 680, 101
- 哪种情况适合使用树的路径遍历算法(最有意思的一种算法我觉得): 257,784, 437, 111, 680也有这个思想, 235, 17, 22, 39, 46, 40, 47, 77, 113, 加权有向图计算两点间所有路径 ,216
- 哪种情况使用DFS或者BFS: 130(二维数组的dfs算法)
- 二分查找:367, 33, 74, 374
- awk题目:193
- 自定义比较器:937
- 二阶矩阵转置+行变换:48(图像顺时针旋转)
- 测试rebase a分支
- 测试rebase b分支
- 测试rebase c分支


## 刷题发现的一些有意思的东西
- 2019.5.16达到250题
- 2019.3.19达到200题
- 2019.12.3达到300题
- ">> n"相当于除以2的n次方, "<< n"相当于除以2的n次方
- 假如A*B,如何获取其结果是正还是负: res = A > 0 == B > 0 ? "+" : "-";
- 类似List<List<E>> 这种结构,如果内层的list的值变化,外层的List的值也会跟着变化,如果内层list会一直变,推荐用new ArrayList(内层list)复制一下后再塞到外层list
- 所有开源项目阅读源码的分支为: kevin_read_source
- 递归运算中,如果是需要一直累积到最终的变量,那么不要在递归中对变量赋值,原因见17题57行注释
- 用for循环迭代一个栈,会发现迭代顺序是先进先出的,所以想先进后出只能pop()
- 求一个数字每位的数:对10求余取个位数的数字的值,然后除10
- 如果a能被b整除,那么必有a % b = 0
- 字符串转成int的思路:num = num * 10 + (str.charAt(i) - '0')
- 2,8,10,16进制的加法中,都可以用除法确定进位值,可以用求余确定该位的最终值,见题目168
- HashSet的add()添加失败时会返回false,可用这个来判数组或list的重复元素
- 判断字符是否'a'~'z'或者'A'~'Z'(英语字母): Character.isLetter(c), 判断字符是数字:Character.isDigit(c)
- idea进入debug时"Finished,saving caches"卡住的解决办法: https://stackoverflow.com/questions/20658400/intellij-idea-hangs-while-finished-saving-caches
- Array转List最有效的办法是Arrays.asList();
- char\[]转string最有效的办法是String.valueOf(char\[]);
- 字符串List转数组最有效的办法是list.toArray(new String\[0]);
- Integer型(int就不行)List转数组最有效办法是list.toArray(new Integer\[0]),不能使用基本类型;
- 某字符串包含某个字符用str.contains(c + "");
- 字符串去掉某个字符应该用str.replace("#", "")双引号而非单引;
- 取余运算(%)效率比较低,特别极端情况下应避免;
- 如何创建一维的二维数组: int\[][] dest = new int\[length]\[1];
- 同样的实现(比如二分查找),迭代花的时间比递归要长,一种说法是函数调用开销比较大;
- 二分查找,中位数的取法:int mid = left + (right - left) /2,要注意mid能不能取到边界索引(0和length-1);
- ArrayList节点,LinkedList节点,HashMap的key....都可以为null,但是ConcurrentHashMap的k和v都不能为null
- StringBuilder在开头插入字符可用sb.insert(0, "x");
- 利用递归计算时,如果需要累积递归的附加效果,则目标变量最好是全局变量(例如690) //不推荐使用全局变量,但不用的话容易出错
- map和set遍历获取元素的效率比list要高,极限场景可以考虑替换(例如217)
- 有些场景慎用Integer.MAX或者MIN,因为这些数字参与运算可能出现溢出,从而出现(正数-负数=负数)的诡异情况,见783解法二
- question136的异或运算:如果两个数对应二进制位相同,那么异或结果为0,如果不同异或结果为1,所以有性质 :0^a = a, b^b=0,所以b^b^a = 0^a = a
