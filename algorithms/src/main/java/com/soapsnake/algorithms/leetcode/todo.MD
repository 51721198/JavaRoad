# 未解决问题阈值:20题
# 没有解决干净的problem:
1. 25min内解不出来(还剩6 chances): 922, 476, 897, 496, 917, 937, 784, 653, 122, 453, 387, 949, 67, 234
2. 题目看不懂: 所有leetcode挂todo的题目: 806, 893
3. 有更巧妙解法: 905, 832, 557, 728, 867, 872, 412, 566, 485, 258, 690, 389, 788, 349, 217, 796, 14
4. 解法需要特殊数学知识: 812(3点坐标求三角形面积), 371(二进制)
5. 一次搞不定还需复习的:


## 刷题发现的一些有意思的东西
- 字符串List转数组最有效的办法是list.toArray(new String[0]);
- int型List转数组最有效办法是list.toArray(new Integer[0]),不能使用基本类型;
- 某字符串包含某个字符用str.contains(c + "");
- 字符串去掉某个字符应该用str.replace("#", "")双引号而非单引;
- 取余运算(%)效率比较低,特别极端情况下应避免;
- 如何创建一维的二维数组: int[][] dest = new int[length][1];
- 同样的实现(比如二分查找),迭代花的时间比递归要长,网上说法是函数调用开销比较大;
- 二分查找,中位索引使用加法,但是要注意mid能不能取到边界索引(0和length-1);
- ArrayList节点,LinkedList节点,HashMap的key....都可以为null;
- StringBuilder在开头插入字符可用sb.insert(0, "x");
- 利用递归计算时,如果需要累积递归的附加效果,则目标变量最好是全局变量(例如690)
- map和set遍历获取元素的效率比list要高,极限场景可以考虑替换(例如217)
- 有些场景慎用Integer.MAX或者MIN,因为这些数字参与运算可能出现溢出,从而出现(正数-负数=负数)的诡异情况,见783解法二
